# .github/workflows/cd.yml
name: CD Build, Push & Deploy to GCE

on:
  push:
    branches: [ main ]
    tags: [ "v*.*.*" ]

###############################################################################
# 1) Build & Push to Docker Hub
###############################################################################
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          github-token: ${{ github.token }}
          images: ${{ secrets.DOCKERHUB_USERNAME }}/myflask
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build & Push image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./apps/api
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-and-push-web:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract web image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          github-token: ${{ github.token }}
          images: ${{ secrets.DOCKERHUB_USERNAME }}/myflask-web
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build & Push web image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./apps/web
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
###############################################################################
# 2) Security Gate (Image Scan + SBOM + Cosign)
###############################################################################
  security-gate:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      security-events: write
    env:
      IMG: ${{ secrets.DOCKERHUB_USERNAME }}/myflask@${{ needs.build-and-push.outputs.image-digest }}

    steps:
      - uses: actions/checkout@v4

      - name: Trivy image scan (SARIF)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMG }}
          vuln-type: 'os,library'
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          format: sarif
          output: trivy-image.sarif
          exit-code: '0'
          scanners: 'vuln'

      - name: Upload Trivy SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif
      
      - name: Trivy table output (debug)
        if: always()
        run: |
          trivy image --scanners vuln --vuln-type os,library \
            --severity HIGH,CRITICAL --ignore-unfixed "${IMG}" || true

      - name: Trivy JSON (for SeveritySource)
        if: always()
        run: |
          set -euo pipefail
          trivy image --scanners vuln \
          --vuln-type os,library \
          --severity HIGH,CRITICAL \
          --ignore-unfixed \
          -f json -o trivy-image.json "${IMG}"

      - name: Enforce Trivy gate from JSON (HIGH/CRIT)
        if: always()
        run: |
          set -euo pipefail
          python - <<'PY'
          import json
          import sys

          with open("trivy-image.json", "r", encoding="utf-8") as f:
              payload = json.load(f)

          count = 0
          for result in payload.get("Results", []) or []:
              vulns = result.get("Vulnerabilities", []) or []
              for vuln in vulns:
                  if str(vuln.get("Severity", "")).upper() in {"HIGH", "CRITICAL"}:
                      count += 1

          print(f"high_critical_count={count}")
          if count > 0:
              sys.exit(1)
          PY


      - name: Upload Trivy JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-json
          path: trivy-image.json
          retention-days: 7

      - name: Login to Docker Hub (for cosign push)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: SBOM (SPDX)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.IMG }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Cosign sign & attest (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          cosign sign --yes "$IMG"
          cosign attest --yes --predicate sbom.spdx.json --type spdx "$IMG"

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-spdx
          path: sbom.spdx.json
          retention-days: 30

###############################################################################
# 3) Deploy to GCE VM
###############################################################################
  deploy:
    needs: [ build-and-push, build-and-push-web, security-gate ]
    runs-on: ubuntu-latest
    env:
      REMOTE_DIR: ${{ secrets.REMOTE_APP_DIR }}
      DOMAIN: ${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      API_IMAGE_REF: ${{ secrets.DOCKERHUB_USERNAME }}/myflask@${{ needs.build-and-push.outputs.image-digest }}
      WEB_IMAGE_REF: ${{ secrets.DOCKERHUB_USERNAME }}/myflask-web@${{ needs.build-and-push-web.outputs.image-digest }}
      IMG: ${{ secrets.DOCKERHUB_USERNAME }}/myflask@${{ needs.build-and-push.outputs.image-digest }}

    steps:
      - uses: actions/checkout@v4

      - name: Validate nginx templates (no BOM)
        run: |
          set -euo pipefail
          for f in infra/nginx/default.http.conf.template infra/nginx/default.https.conf.template; do
            if LC_ALL=C grep -n $'^\xEF\xBB\xBF' "$f" >/dev/null; then
              echo "BOM detected in $f. Save as UTF-8 without BOM."
              exit 1
            fi
          done
      
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Verify image signature (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          cosign verify \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}(/.*)?" \
            "${IMG}" > /dev/null

          echo "cosign verify OK for ${IMG}"

      # 0) SSH setup
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GCP_SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H ${{ secrets.GCP_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          if [ -n "${{ secrets.GCP_HOST_KEY }}" ]; then
            echo "${{ secrets.GCP_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "echo OK"

      # 1) Prepare remote directory and .env
      - name: Prepare remote directory & .env
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} <<'EOF'
            mkdir -p "${{ env.REMOTE_DIR }}"/{nginx,api-data,certbot/{config,www,logs}}
            chmod 0777 "${{ env.REMOTE_DIR }}/api-data"

            cat > "${{ env.REMOTE_DIR }}/.env" <<EOT
            DOMAIN=${{ env.DOMAIN }}
            LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}
            API_IMAGE_REF=${{ env.API_IMAGE_REF }}
            WEB_IMAGE_REF=${{ env.WEB_IMAGE_REF }}
            GITHUB_OWNER=${{ secrets.GH_OWNER }}
            GITHUB_REPO=${{ secrets.GH_REPO }}
            GITHUB_TOKEN=${{ secrets.GH_TOKEN }}
            SYNC_TOKEN=${{ secrets.SYNC_TOKEN }}
            DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            EOT
          EOF


      # 2) Upload HTTP-only Nginx template and compose file
      - name: Upload HTTP-only Nginx template and compose
        run: |
          scp -o StrictHostKeyChecking=no infra/nginx/default.http.conf.template \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"
          scp -o StrictHostKeyChecking=no infra/docker/docker-compose.prod.yml \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"${{ env.REMOTE_DIR }}/"

      # 3) Start HTTP-only stack on port 80
      - name: Start HTTP-only stack
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml down --remove-orphans || true &&
            docker system prune -af || true &&
            docker builder prune -af || true &&
            docker container prune -f || true &&
            docker compose -f docker-compose.prod.yml up -d nginx api web
          "

      # 4) Wait for HTTP readiness
      - name: Wait for HTTP health endpoint
        run: |
          if [[ "${{ env.DOMAIN }}" == http://* || "${{ env.DOMAIN }}" == https://* ]]; then
            echo "DOMAIN secret must be hostname only (no scheme): '${{ env.DOMAIN }}'"
            exit 1
          fi

          HEALTH_URL="http://${{ env.DOMAIN }}/health"
          ok=0
          for i in {1..30}; do
            if curl -sSf -m 10 "${HEALTH_URL}" >/dev/null 2>&1; then
              echo "HTTP health OK: ${HEALTH_URL}"
              ok=1
              break
            fi
            echo "...waiting HTTP health (${i}/30): ${HEALTH_URL}"; sleep 5
          done
          if [ "$ok" -ne 1 ]; then
            echo "HTTP health verification failed for ${HEALTH_URL}"
            exit 1
          fi

      - name: Diagnose HTTP failure
        if: failure()
        run: |
          echo "=== runner-side checks ==="
          getent hosts ${{ env.DOMAIN }} || true
          curl -vk --max-time 10 http://${{ env.DOMAIN }}/health || true
          curl -vk --max-time 10 http://${{ env.DOMAIN }}/ || true

          echo "=== remote-side checks ==="
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            set -x
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yml ps || true
            docker compose -f docker-compose.prod.yml logs --tail=150 nginx || true
            docker compose -f docker-compose.prod.yml logs --tail=150 api || true
            docker compose -f docker-compose.prod.yml logs --tail=150 web || true
            ss -ltnp | grep ':80\\|:443' || true
            curl -vk --max-time 10 -H 'Host: ${{ env.DOMAIN }}' http://127.0.0.1/health || true
            curl -vk --max-time 10 -H 'Host: ${{ env.DOMAIN }}' http://127.0.0.1 || true
          "

      # 5) Issue or renew certificates
      - name: Issue / Renew SSL
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml run --rm certbot \
              certonly --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' -d '${{ env.DOMAIN }}' \
              --agree-tos --no-eff-email --rsa-key-size 4096
          "

      # 6) Ensure SSL helper files for Nginx
      - name: Provide ssl helper files for nginx
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} <<'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot sh -euxc '
              OPTIONS=/etc/letsencrypt/options-ssl-nginx.conf
              DHPARAM=/etc/letsencrypt/ssl-dhparams.pem

              # Ensure target directory exists
              mkdir -p /etc/letsencrypt

              # Ensure options-ssl-nginx.conf exists
              if [ ! -f "$OPTIONS" ]; then
                SRC=$(find /usr /opt -maxdepth 7 -type f -name options-ssl-nginx.conf 2>/dev/null | head -n1 || true)
                if [ -n "$SRC" ]; then
                  cp "$SRC" "$OPTIONS"
                elif command -v curl >/dev/null 2>&1; then
                  curl -fsSL \
                    https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf \
                    -o "$OPTIONS" || true
                fi
              fi

              # Fallback TLS options
              if [ ! -s "$OPTIONS" ]; then
                printf "%s\n" \
                  "ssl_session_cache   shared:SSL:10m;" \
                  "ssl_session_timeout 1h;" \
                  "ssl_prefer_server_ciphers on;" \
                  "ssl_protocols TLSv1.2 TLSv1.3;" \
                  "ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;" \
                  > "$OPTIONS"
              fi

              # Create dhparam file if missing
              if [ ! -f "$DHPARAM" ]; then
                openssl dhparam -out "$DHPARAM" 2048
              fi
            '
          EOF

      # 7) Upload HTTPS Nginx template
      - name: Upload HTTPS Nginx template
        run: |
          scp -o StrictHostKeyChecking=no infra/nginx/default.https.conf.template \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"

      # 8) Render Nginx config and reload
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} <<'EOF'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'
            cid="$(docker compose -f docker-compose.prod.yml ps -q nginx)"
            if [ -z "$cid" ]; then
              echo "nginx container not found"
              docker compose -f docker-compose.prod.yml ps || true
              exit 1
            fi

            for i in {1..30}; do
              state="$(docker inspect -f '{{.State.Status}}' "$cid" 2>/dev/null || true)"
              if [ "$state" = "running" ]; then
                echo "nginx is running"
                break
              fi
              echo "waiting nginx state=${state:-unknown} (${i}/30)"
              sleep 2
            done

            state="$(docker inspect -f '{{.State.Status}}' "$cid" 2>/dev/null || true)"
            if [ "$state" != "running" ]; then
              echo "nginx did not become running (state=$state)"
              docker compose -f docker-compose.prod.yml logs --tail=150 nginx || true
              exit 1
            fi

            docker compose -f docker-compose.prod.yml exec -T nginx sh -ceu '
              envsubst '\''$DOMAIN'\'' \
                < /etc/nginx/templates/default.conf.template \
                > /etc/nginx/conf.d/default.conf
              nginx -t
              nginx -s reload
            '
          EOF

      # 9) Reclaim disk before pull (avoid no space left on device)
      - name: Reclaim docker disk space
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            set -euxo pipefail
            df -h || true
            docker system df || true
            docker image prune -af || true
            docker builder prune -af || true
            docker container prune -f || true
            docker system df || true
            df -h || true
          "

      # 10) Ensure full stack services (avoid duplicate pull on low-disk hosts)
      - name: Ensure full stack services
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml up -d --remove-orphans
          "

      # 11) Verify HTTPS readiness
      - name: Verify HTTPS
        run: |
          ok=0
          for i in {1..12}; do
            if curl -sSf -m 5 https://${{ env.DOMAIN }} >/dev/null 2>&1; then
              echo "HTTPS OK"
              ok=1
              break
            fi
            echo "...waiting HTTPS (${i}/12)"; sleep 10
          done
          if [ "$ok" -ne 1 ]; then
            echo "HTTPS verification failed for https://${{ env.DOMAIN }}"
            exit 1
          fi

      - name: Diagnose HTTPS failure
        if: failure()
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            set -x
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yml ps
            docker compose -f docker-compose.prod.yml logs --tail=150 nginx || true
            ls -al certbot/config/live/${{ env.DOMAIN }} || true
            ls -al certbot/config || true
            ss -ltnp | grep ':443' || true
            curl -vk --max-time 10 https://${{ env.DOMAIN }} || true
          "

      # 12) Prune old images
      - name: Prune images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "docker image prune -f --filter 'until=24h' || true"

###############################################################################
# 4) Notifications
###############################################################################
  notify:
    needs: [ build-and-push, build-and-push-web, deploy ]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Success notice
        if: success()
        run: echo "Deployed to ${{ secrets.DOMAIN }}"

      - name: Failure notice
        if: failure()
        run: echo "Deployment to ${{ secrets.DOMAIN }} failed"
      

