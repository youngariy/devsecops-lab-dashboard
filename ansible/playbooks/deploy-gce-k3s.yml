---
- name: Deploy sample flask app to k3s
  hosts: k3s
  become: true
  vars:
    app_name: "{{ lookup('env', 'APP_NAME') | default('flask-app', true) }}"
    namespace: "{{ lookup('env', 'K8S_NAMESPACE') | default('flask-app', true) }}"
    image_ref_env: "{{ lookup('env', 'IMAGE_REF') | default('', true) | trim }}"
    dockerhub_username: "{{ lookup('env', 'DOCKERHUB_USERNAME') | default('', true) | trim }}"
    image_ref_fallback: "{{ (dockerhub_username ~ '/' ~ app_name ~ ':latest') if (dockerhub_username | length > 0) else (app_name ~ ':latest') }}"
    image_ref: "{{ image_ref_env if (image_ref_env | length > 0) else image_ref_fallback }}"
    replicas: "{{ lookup('env', 'REPLICAS') | default('2', true) | int }}"
    service_type: "{{ lookup('env', 'SERVICE_TYPE') | default('ClusterIP', true) }}"
    node_port: "{{ lookup('env', 'K3S_NODE_PORT') | default('30080', true) | int }}"
    domain_env: "{{ lookup('env', 'DOMAIN') | default('', true) | trim }}"
    ingress_host_env: "{{ lookup('env', 'INGRESS_HOST') | default('', true) | trim }}"
    ingress_host: "{{ ingress_host_env if (ingress_host_env | length > 0) else domain_env }}"
    tls_enabled: "{{ (ingress_host | length > 0) | bool }}"
    letsencrypt_email: "{{ lookup('env', 'LETSENCRYPT_EMAIL') | default('', true) | trim }}"
    tls_secret_name: "{{ lookup('env', 'TLS_SECRET_NAME') | default(app_name ~ '-tls', true) }}"
    certbot_contact_arg: "{{ '--email ' ~ letsencrypt_email if (letsencrypt_email | length > 0) else '--register-unsafely-without-email' }}"
    cert_fullchain_path: "/etc/letsencrypt/live/{{ ingress_host }}/fullchain.pem"
    cert_privkey_path: "/etc/letsencrypt/live/{{ ingress_host }}/privkey.pem"
    container_port: 5000
    k3s_install_exec: "--write-kubeconfig-mode 644"

  pre_tasks:
    - name: Show selected image reference
      ansible.builtin.debug:
        msg:
          - "image_ref={{ image_ref }}"
          - "source={{ 'IMAGE_REF' if (image_ref_env | length > 0) else 'fallback(latest)' }}"
          - "ingress_host={{ ingress_host if (ingress_host | length > 0) else '<none>' }}"
          - "tls_enabled={{ tls_enabled }}"
          - "service_type={{ service_type }}"
          - "tls_secret_name={{ tls_secret_name }}"
          - "certbot_email={{ letsencrypt_email if (letsencrypt_email | length > 0) else '<none>' }}"

    - name: Ensure service type is valid
      ansible.builtin.assert:
        that:
          - service_type in ['ClusterIP', 'NodePort', 'LoadBalancer']
        fail_msg: "SERVICE_TYPE must be one of: ClusterIP, NodePort, LoadBalancer."

    - name: Ensure node port range is valid
      ansible.builtin.assert:
        that:
          - node_port >= 30000
          - node_port <= 32767
        fail_msg: "K3S_NODE_PORT must be in the range 30000-32767."
      when: service_type == 'NodePort'

  tasks:
    - name: Validate required vars
      ansible.builtin.assert:
        that:
          - image_ref | length > 0
        fail_msg: "Set IMAGE_REF or DOCKERHUB_USERNAME/APP_NAME so image_ref resolves."

    - name: Install curl and openssl
      ansible.builtin.apt:
        name:
          - curl
          - openssl
        state: present
        update_cache: true

    - name: Check whether k3s binary exists
      ansible.builtin.command: bash -lc "command -v k3s"
      register: k3s_bin
      failed_when: false
      changed_when: false

    - name: Install k3s if missing
      ansible.builtin.shell: |
        set -euo pipefail
        curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="{{ k3s_install_exec }}" sh -
      args:
        executable: /bin/bash
      when: k3s_bin.rc != 0

    - name: Detect k3s service option '--disable traefik'
      ansible.builtin.shell: |
        set -euo pipefail
        awk '
          /--disable[[:space:]]+traefik/ { found=1 }
          /--disable/ { disable_line=NR }
          disable_line && NR <= (disable_line + 3) && /traefik/ { found=1 }
          END { exit found ? 0 : 1 }
        ' /etc/systemd/system/k3s.service
      args:
        executable: /bin/bash
      register: k3s_disable_traefik
      failed_when: false
      changed_when: false
      when: k3s_bin.rc == 0

    - name: Reconfigure k3s to enable traefik
      ansible.builtin.shell: |
        set -euo pipefail
        curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="{{ k3s_install_exec }}" sh -
      args:
        executable: /bin/bash
      when:
        - k3s_bin.rc == 0
        - k3s_disable_traefik.rc == 0

    - name: Ensure k3s service is started and enabled
      ansible.builtin.systemd:
        name: k3s
        state: started
        enabled: true

    - name: Ensure kubeconfig is readable
      ansible.builtin.file:
        path: /etc/rancher/k3s/k3s.yaml
        mode: "0644"

    - name: Ensure kubectl symlink exists
      ansible.builtin.file:
        src: /usr/local/bin/k3s
        dest: /usr/local/bin/kubectl
        state: link
        force: true

    - name: Wait for kubectl API access
      ansible.builtin.command: kubectl get ns kube-system
      register: kubectl_ready
      retries: 12
      delay: 5
      until: kubectl_ready.rc == 0
      changed_when: false

    - name: Wait until traefik deployment exists
      ansible.builtin.command: kubectl -n kube-system get deployment traefik
      register: traefik_exists
      changed_when: false
      retries: 24
      delay: 5
      until: traefik_exists.rc == 0

    - name: Wait for traefik rollout
      ansible.builtin.command: kubectl -n kube-system rollout status deployment/traefik --timeout=240s
      changed_when: false

    - name: Manage TLS certificate with certbot
      when: tls_enabled
      block:
        - name: Install certbot package for TLS issuance
          ansible.builtin.apt:
            name: certbot
            state: present
            update_cache: true

        - name: Issue or renew Let's Encrypt certificate using certbot
          ansible.builtin.shell: |
            set -euo pipefail
            # Skip re-issue if existing cert is valid for more than 30 days.
            if [ -s "{{ cert_fullchain_path }}" ] && openssl x509 -checkend 2592000 -noout -in "{{ cert_fullchain_path }}"; then
              echo "Existing cert for {{ ingress_host }} is valid for more than 30 days. Skip re-issue."
              exit 0
            fi
            trap 'systemctl start k3s || true' EXIT
            systemctl stop k3s
            if command -v k3s-killall.sh >/dev/null 2>&1; then
              # Clear k3s processes/iptables temporarily for standalone challenge.
              k3s-killall.sh || true
            fi
            certbot certonly \
              --standalone \
              --preferred-challenges http \
              --non-interactive \
              --agree-tos \
              --keep-until-expiring \
              {{ certbot_contact_arg }} \
              -d "{{ ingress_host }}"
            systemctl start k3s
            trap - EXIT
          args:
            executable: /bin/bash

        - name: Ensure certbot certificate files exist
          ansible.builtin.stat:
            path: "{{ cert_fullchain_path }}"
          register: certbot_fullchain

        - name: Validate certbot certificate was created
          ansible.builtin.assert:
            that:
              - certbot_fullchain.stat.exists
            fail_msg: "certbot certificate creation failed: {{ cert_fullchain_path }}"

    - name: Ensure target namespace exists before TLS secret apply
      ansible.builtin.shell: |
        set -euo pipefail
        kubectl create namespace {{ namespace }} --dry-run=client -o yaml | kubectl apply -f -
      args:
        executable: /bin/bash

    - name: Upsert Kubernetes TLS secret from certbot output
      ansible.builtin.shell: |
        set -euo pipefail
        kubectl -n {{ namespace }} create secret tls {{ tls_secret_name }} \
          --cert={{ cert_fullchain_path }} \
          --key={{ cert_privkey_path }} \
          --dry-run=client -o yaml | kubectl apply -f -
      args:
        executable: /bin/bash
      when: tls_enabled

    - name: Render app manifest
      ansible.builtin.template:
        src: ../manifests/k3s-app.yaml.j2
        dest: /tmp/{{ app_name }}.yaml
        mode: "0644"

    - name: Apply manifest
      ansible.builtin.command: kubectl apply -f /tmp/{{ app_name }}.yaml

    - name: Wait for deployment rollout
      ansible.builtin.command: kubectl -n {{ namespace }} rollout status deployment/{{ app_name }} --timeout=240s
      changed_when: false

    - name: Verify HTTPS does not serve Traefik default certificate
      ansible.builtin.shell: |
        set -euo pipefail
        cert_info="$(echo | openssl s_client -connect {{ ingress_host }}:443 -servername {{ ingress_host }} 2>/dev/null | openssl x509 -noout -subject -issuer)"
        echo "$cert_info"
        if echo "$cert_info" | grep -qi "TRAEFIK DEFAULT CERT"; then
          echo "Traefik default certificate is still being served."
          exit 1
        fi
      args:
        executable: /bin/bash
      register: cert_served_check
      retries: 24
      delay: 5
      until: cert_served_check.rc == 0
      changed_when: false
      when: tls_enabled

    - name: Show deployment and service status
      ansible.builtin.command: kubectl -n {{ namespace }} get deployment,service -o wide
      register: workload_status
      changed_when: false

    - name: Print status
      ansible.builtin.debug:
        var: workload_status.stdout_lines

    - name: Show access hint
      ansible.builtin.debug:
        msg:
          - "Access URL (HTTP): http://{{ ingress_host if (ingress_host | length > 0) else inventory_hostname }}/"
          - "Access URL (HTTPS): https://{{ ingress_host if (ingress_host | length > 0) else inventory_hostname }}/"
          - "TLS Secret: {{ tls_secret_name if (ingress_host | length > 0) else 'N/A (no ingress host)' }}"
          - "Ports 80/443 are routed by traefik ingress."
